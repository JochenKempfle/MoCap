/*Copyright (c) 2014, Jochen KempfleAll rights reserved.Redistribution and use in source and binary forms, with or without modification,are permitted provided that the following conditions are met:1. Redistributions of source code must retain the above copyright notice,this list of conditions and the following disclaimer.2. Redistributions in binary form must reproduce the above copyright notice,this list of conditions and the following disclaimer in the documentation and/orother materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" ANDANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITYOF SUCH DAMAGE.*/#include "MoCapManager.h"#include <GL/gl.h>#include <GL/glu.h>#include "SensorManager.h"MoCapManager::MoCapManager(){    // create a skeleton    _rShoulderId = _lShoulderId = _rHipId = _lHipId = -1;    createSkeleton();}MoCapManager::~MoCapManager(){    //dtor}MoCapManager* MoCapManager::_moCapManager = nullptr;MoCapManager& MoCapManager::getInstance(){    if (_moCapManager == nullptr)    {        _moCapManager = new MoCapManager();    }    return *_moCapManager;}void MoCapManager::assignSensorToBone(int sensorId, int boneId){    if (sensorId < 0)    {        return;    }    else if (boneId < 0)    {        theMoCapManager.removeSensorFromBones(sensorId);        return;    }    // get the sensor which was assigned to chosen bone before and remove it from the bone    theMoCapManager.removeSensorFromBones(sensorId);    int prevSensorId = theMoCapManager.getSensorIdFromBoneId(boneId);    theMoCapManager.removeSensorFromBones(prevSensorId);    _boneIdFromSensorId[sensorId] = boneId;    _sensorIdFromBoneId[boneId] = sensorId;    theSensorManager.setSensorStateHasBone(sensorId, true);}void MoCapManager::removeSensorFromBones(int sensorId){    auto it = _boneIdFromSensorId.find(sensorId);    if (it != _boneIdFromSensorId.end())    {        _sensorIdFromBoneId.erase(it->second);        _boneIdFromSensorId.erase(sensorId);        theSensorManager.setSensorStateHasBone(sensorId, false);    }}int MoCapManager::getSensorIdFromBoneId(int boneId){    auto it = _sensorIdFromBoneId.find(boneId);    if (it != _sensorIdFromBoneId.end())    {        return it->second;    }    return -1;}int MoCapManager::getBoneIdFromSensorId(int sensorId){    auto it = _boneIdFromSensorId.find(sensorId);    if (it != _boneIdFromSensorId.end())    {        return it->second;    }    return -1;}void MoCapManager::assignNameToBone(std::string name, int boneId){    _boneNameFromId[boneId] = name;}std::vector<int> MoCapManager::getBoneIds(){    return _skeleton.getBoneIds();}std::vector<std::pair<int, std::string> > MoCapManager::getBoneIdsWithName(){    std::vector<std::pair<int, std::string> > bones;    for (auto it = _boneNameFromId.begin(); it != _boneNameFromId.end(); ++it)    {        bones.push_back(*it);    }    return bones;}std::string MoCapManager::getBoneNameFromId(int id){    std::string name;    auto it = _boneNameFromId.find(id);    if (it != _boneNameFromId.end())    {        name = it->second;    }    return name;}void MoCapManager::resetSkeleton(){    _skeleton.clear();    createSkeleton();    // TODO(JK#9#): rewrite bone associations (i.e. sensor-bone ids and names) for now it works but with custom skeletons this will cause trouble!}void MoCapManager::calibrate(){    std::vector<SensorNode> sensors = theSensorManager.getSensors();    for (size_t i = 0; i < sensors.size(); ++i)    {        Quaternion rotationOffset = sensors[i].getRotation().inv();        if (theSensorManager.setSensorOffset(sensors[i].getId(), rotationOffset))        {            theSensorManager.setSensorStateCalibrated(sensors[i].getId(), true);        }        // TODO(JK#1#): calibration! If bone.dir does not match, rotate 180° around y    }}void MoCapManager::update(){    std::vector<SensorNode> sensors = theSensorManager.getSensors();    for (size_t i = 0; i < sensors.size(); ++i)    {        int boneId = getBoneIdFromSensorId(sensors[i].getId());        _skeleton.setBoneRotation(boneId, sensors[i].getCalRotation());    }    // update static bones (bones without user access)    _skeleton.setBoneRotation(_rShoulderId, _skeleton.getBone(_rShoulderId).getParent()->getRotation()                * Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0) * Quaternion(Vector3(0.0, 1.0, 0.0), M_PI*90.0/180.0));    _skeleton.setBoneRotation(_lShoulderId, _skeleton.getBone(_lShoulderId).getParent()->getRotation()                * Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0) * Quaternion(Vector3(0.0, -1.0, 0.0), M_PI*90.0/180.0));    _skeleton.setBoneRotation(_rHipId, _skeleton.getBone(_rHipId).getParent()->getRotation()                * Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0) * Quaternion(Vector3(0.0, 1.0, 0.0), M_PI*90.0/180.0));    _skeleton.setBoneRotation(_lHipId, _skeleton.getBone(_lHipId).getParent()->getRotation()                * Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0) * Quaternion(Vector3(0.0, -1.0, 0.0), M_PI*90.0/180.0));    // update not static bones without sensor    // TODO(JK#9#): update upper leg bones without sensor somehow else, not this hardcoded way    std::vector<int> bones = _skeleton.getBoneIds();    for (size_t i = 0; i < bones.size(); ++i)    {        if (getSensorIdFromBoneId(bones[i]) < 0 && getBoneNameFromId(bones[i]).length() > 0)        {            Bone bone = _skeleton.getBone(bones[i]);            std::string name = getBoneNameFromId(bones[i]);            if (bone.getParent() == nullptr)            {                continue;            }            else if (name.compare("rUpperLeg") == 0)            {                _skeleton.setBoneRotation(bones[i], bone.getParent()->getRotation() * Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0));            }            else if (name.compare("lUpperLeg") == 0)            {                _skeleton.setBoneRotation(bones[i], bone.getParent()->getRotation() * Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0));            }            else            {                _skeleton.setBoneRotation(bones[i], bone.getParent()->getRotation());            }        }    }    // as for now only the new rotations were set, update the skeleton to also get new bone positions    _skeleton.update();}void MoCapManager::render(){    for (auto it = _skeleton.beginBones(); it != _skeleton.endBones(); ++it)    {        Bone bone = *(it->second);        Vector3 startPos = bone.getStartPos();        Vector3 endPos = bone.getEndPos();        float length = bone.getLength();        Vector3 dir = bone.getDirection();        Vector3 up = bone.getUpDirection();        Vector3 right = bone.getRightDirection();        Vector3 upPoint = startPos + up*length*0.1 + dir*length*0.1;        Vector3 downPoint = startPos - up*length*0.1 + dir*length*0.1;        Vector3 rightPoint = startPos + right*length*0.1 + dir*length*0.1;        Vector3 leftPoint = startPos - right*length*0.1 + dir*length*0.1;        //set point size to 10 pixels        glPointSize(10.0f);        glColor4f(0.02, 0.06, 0.6, 1.0);        glBegin(GL_POINTS);            //glVertex3f(startPos.x(), startPos.y(), startPos.z());            glVertex3f(endPos.x(), endPos.y(), endPos.z());        glEnd();        glColor4f(1.0, 0.0, 0.0, 1.0);        // draw local coordinate system/*        glBegin(GL_LINES);            glVertex3f(startPos.x(), startPos.y(), startPos.z());            glVertex3f(endPos.x(), endPos.y(), endPos.z());            glColor4f(0.0, 1.0, 0.0, 1.0);            glVertex3f(endPos.x(), endPos.y(), endPos.z());            glVertex3f(endPos.x() + up.x()*0.1, endPos.y() + up.y()*0.1, endPos.z() + up.z()*0.1);            glColor4f(0.0, 0.0, 1.0, 1.0);            glVertex3f(endPos.x(), endPos.y(), endPos.z());            glVertex3f(endPos.x() + right.x()*0.1, endPos.y() + right.y()*0.1, endPos.z() + right.z()*0.1);        glEnd();*/        // draw bone        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);        glColor4f(0.5, 0.5, 0.5, 1.0);        glBegin(GL_TRIANGLE_FAN);            glVertex3f(startPos.x(), startPos.y(), startPos.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());            glVertex3f(rightPoint.x(), rightPoint.y(), rightPoint.z());            glVertex3f(downPoint.x(), downPoint.y(), downPoint.z());            glVertex3f(leftPoint.x(), leftPoint.y(), leftPoint.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());        glEnd();        glColor4f(0.7, 0.7, 0.7, 1.0);        glBegin(GL_TRIANGLE_FAN);            glVertex3f(endPos.x(), endPos.y(), endPos.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());            glVertex3f(rightPoint.x(), rightPoint.y(), rightPoint.z());            glVertex3f(downPoint.x(), downPoint.y(), downPoint.z());            glVertex3f(leftPoint.x(), leftPoint.y(), leftPoint.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());        glEnd();        // draw black mesh lines around bones        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);        glColor4f(0.0, 0.0, 0.0, 1.0);        glBegin(GL_TRIANGLE_FAN);            glVertex3f(startPos.x(), startPos.y(), startPos.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());            glVertex3f(rightPoint.x(), rightPoint.y(), rightPoint.z());            glVertex3f(downPoint.x(), downPoint.y(), downPoint.z());            glVertex3f(leftPoint.x(), leftPoint.y(), leftPoint.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());        glEnd();        glBegin(GL_TRIANGLE_FAN);            glVertex3f(endPos.x(), endPos.y(), endPos.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());            glVertex3f(rightPoint.x(), rightPoint.y(), rightPoint.z());            glVertex3f(downPoint.x(), downPoint.y(), downPoint.z());            glVertex3f(leftPoint.x(), leftPoint.y(), leftPoint.z());            glVertex3f(upPoint.x(), upPoint.y(), upPoint.z());        glEnd();    }}void MoCapManager::createSkeleton(){    Bone boneData;    // hip - this will be the anchor of the skeleton    boneData.setStartPos(Vector3(0.0, 1.0, 0.0));    boneData.setLength(0.001);    boneData.setRotation(Quaternion(Vector3(0.0, 0.0, 1.0), M_PI*90.0/180.0) * Quaternion(Vector3(-1.0, 0.0, 0.0), M_PI*90.0/180.0));    int hip = _skeleton.createBone(boneData);    assignNameToBone("hip", hip);    // hip - neck (i.e. the body)    boneData.setLength(0.55);    boneData.setRotation(Quaternion(Vector3(0.0, 0.0, 1.0), M_PI*90.0/180.0) * Quaternion(Vector3(-1.0, 0.0, 0.0), M_PI*90.0/180.0));    int neck = _skeleton.createBone(boneData, hip);    assignNameToBone("body", neck);    // neck - head    boneData.setLength(0.30);    boneData.setRotation(Quaternion(Vector3(0.0, 0.0, 1.0), M_PI*90.0/180.0) * Quaternion(Vector3(-1.0, 0.0, 0.0), M_PI*90.0/180.0));    int head = _skeleton.createBone(boneData, neck);    assignNameToBone("head", head);    // neck - right shoulder    boneData.setLength(0.20);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), 0.0));    _rShoulderId = _skeleton.createBone(boneData, neck);    // assignNameToBone("rShoulder", _rShoulderId);    // right upper arm    boneData.setLength(0.35);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), 0.0));    int rUpperArm = _skeleton.createBone(boneData, _rShoulderId);    assignNameToBone("rUpperArm", rUpperArm);    // right lower arm    boneData.setLength(0.30);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), 0.0));    int rLowerArm = _skeleton.createBone(boneData, rUpperArm);    assignNameToBone("rLowerArm", rLowerArm);    // neck - left shoulder    boneData.setLength(0.20);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), M_PI*180.0/180.0));    _lShoulderId = _skeleton.createBone(boneData, neck);    // assignNameToBone("lShoulder", _lShoulderId);    // left upper arm    boneData.setLength(0.35);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), M_PI*180.0/180.0));    int lUpperArm = _skeleton.createBone(boneData, _lShoulderId);    assignNameToBone("lUpperArm", lUpperArm);    // left lower arm    boneData.setLength(0.30);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), M_PI*180.0/180.0));    int lLowerArm = _skeleton.createBone(boneData, lUpperArm);    assignNameToBone("lLowerArm", lLowerArm);    // hip - right leg    boneData.setLength(0.20);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), 0.0));    _rHipId = _skeleton.createBone(boneData, hip);    // assignNameToBone("rHip", _rHipId);    // right upper leg    boneData.setLength(0.45);    boneData.setRotation(Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0));    int rUpperLeg = _skeleton.createBone(boneData, _rHipId);    assignNameToBone("rUpperLeg", rUpperLeg);    // right lower leg    boneData.setLength(0.45);    boneData.setRotation(Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0));    int rLowerLeg = _skeleton.createBone(boneData, rUpperLeg);    assignNameToBone("rLowerLeg", rLowerLeg);    // hip - left leg    boneData.setLength(0.20);    boneData.setRotation(Quaternion(Vector3(0.0, 1.0, 0.0), M_PI*180.0/180.0));    _lHipId = _skeleton.createBone(boneData, hip);    // assignNameToBone("lHip", _lHipId);    // left upper leg    boneData.setLength(0.45);    boneData.setRotation(Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0));    int lUpperLeg = _skeleton.createBone(boneData, _lHipId);    assignNameToBone("lUpperLeg", lUpperLeg);    // left lower leg    boneData.setLength(0.45);    boneData.setRotation(Quaternion(Vector3(0.0, 0.0, -1.0), M_PI*90.0/180.0));    int lLowerLeg = _skeleton.createBone(boneData, lUpperLeg);    assignNameToBone("lLowerLeg", lLowerLeg);    _skeleton.update();}