/*Copyright (c) 2014, Jochen KempfleAll rights reserved.Redistribution and use in source and binary forms, with or without modification,are permitted provided that the following conditions are met:1. Redistributions of source code must retain the above copyright notice,this list of conditions and the following disclaimer.2. Redistributions in binary form must reproduce the above copyright notice,this list of conditions and the following disclaimer in the documentation and/orother materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" ANDANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITYOF SUCH DAMAGE.*/#include "Skeleton.h"Skeleton::Skeleton(){    //ctor    _nextId = 0;}Skeleton::~Skeleton(){    clear();    //dtor}int Skeleton::createBone(int parent){    int id = _nextId++;    Bone* bone = new Bone(id);    _bones[id] = bone;    // check if parent exists    auto it = _bones.find(parent);    if (it == _bones.end())    {        // if parent does not exist, the bone becomes a root bone        _rootBones.push_back(bone);    }    else    {        // if parent exists, add bone to its children        it->second->appendChild(bone);        bone->setParent(it->second);    }    return id;}int Skeleton::createBone(const Bone& boneData, int parent){    int id = _nextId++;    Bone* bone = new Bone(id, boneData);    _bones[id] = bone;    // check if parent exists    auto it = _bones.find(parent);    if (it == _bones.end())    {        // if parent does not exist, the bone becomes a root bone        _rootBones.push_back(bone);    }    else    {        // if parent exists, add bone to its children        it->second->appendChild(bone);        bone->setParent(it->second);    }    return id;}void Skeleton::deleteBone(int id){    // TODO(JK#9#): delete the bone and its children. Or do not allow to delete a bone}void Skeleton::clear(){    // delete all bones    for (auto it = _bones.begin(); it != _bones.end(); ++it)    {        delete it->second;    }    _rootBones.clear();    _bones.clear();    _nextId = 0;}std::vector<int> Skeleton::getBoneIds(){    std::vector<int> ids;    auto it = _bones.begin();    for (; it != _bones.end(); ++it)    {        ids.push_back(it->first);    }    return ids;}Bone Skeleton::getBone(int id) const{    auto it = _bones.find(id);    if (it != _bones.end())    {        return *(it->second);    }    // TODO(JK#9#): instead of returning a bone dummy, throw an exception    Bone dummy;    return dummy;}bool Skeleton::setBoneData(int id, const Bone &boneData){    auto it = _bones.find(id);    if (it != _bones.end())    {        it->second->copyContent(boneData);        return true;    }    return false;}bool Skeleton::setBoneRotation(int id, const Quaternion &rotation){    auto it = _bones.find(id);    if (it != _bones.end())    {        it->second->setRotation(rotation);        return true;    }    return false;}void Skeleton::update(){    // when updating root bones, their children will automatically get updated recursively    for (size_t i = 0; i < _rootBones.size(); ++i)    {        _rootBones[i]->update();    }}